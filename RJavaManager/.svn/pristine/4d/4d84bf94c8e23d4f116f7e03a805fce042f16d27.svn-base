#----------------------------------------------------#
#MDS - Function for performing Multidimensional Scaling   #
#
# data - name of R dataframe
# outputPath - folder where graph(s) will be saved
# vars - vector of names of the numeric variables
# idVar - name of the ID variable
# distance - distance measure to use
# type - type of MDS to perform
# dimnum - number of dimensions to be used
# useIdVar - logical; whether an ID variable will be used to label points in the plot or not
# pChars - vector representing characters for the points in the plot
# pSizes - vector representing sizes of points in the plot
# pCol - vector representing colors of points in the plot 
# showLeg - logical; whether a legend is displayed or not
# legTitle - title of the legend, if any
# legPos - position of the legend in the plot 
# legNcol - number of columns for the legend
#----------------------------------------------------#

MDS <-function(data, outputPath, vars, idVar, distance = c("Euclidean","Maximum","Manhattan","Minkowski","Canberra"),
	            type = c("Classical", "Nonmetric"), dimnum = 2,
              useIdVar = FALSE, pChars, pSizes, pCol, 
              showLeg = FALSE, legTitle, legPos = "bottomright", legNcol = 1) {

  if (is.character(data)) { 
		nameData <- data
	
    if (!exists(nameData)) { stop(paste("The object '", nameData,"' does not exists.", sep = "")) }
		tempData <- eval(parse(text = data)) 
  	
    } else {
      if (is.data.frame(data)) { 
		  nameData <- paste(deparse(substitute(data)))	
		  tempData <- data	
		  } else { stop ("The argument should either be a data frame or a character string indicating the name of the data frame.") }
  	}
  
	if (!is.data.frame(tempData)) { stop("The object should be of type data frame.") }
	if (!is.character(vars)) 	{ stop(paste("The object 'vars' should be a character vector.", sep = "")) }
	if (any(is.na(match(vars, names(tempData))))) { stop("At least one item in the character vector 'vars' does not match any variable name in the dataset.") }
    
	distance <- match.arg(distance)
  type <- match.arg(type)
	options(width = 5000, digits = 6)

	if (type == "Classical") {
	  cat("CLASSICAL MULTIDIMENSIONAL SCALING \n\n")    
    d <- dist(tempData[,vars], method = tolower(distance))

    capture.output(fit <- cmdscale(d, eig=TRUE, k=as.numeric(dimnum))) # k is the number of dimensions

    points <- data.frame(fit$points)
    colnames(points) <- make.unique(rep("MDS",dimnum+1),sep ="")[2:(dimnum+1)]
    cat("\nPOINTS\n\n")
  	print(points)
		cat("\n")
		
	  eigenOut <- data.frame(fit$eig)
	  cat("\nEIGENVALUES\n")
	  colnames(eigenOut) <- ""
    print(eigenOut)
    
    cat("\nP_", dimnum, " criterion: ", round(fit$GOF[1], digits = 4), sep = "")
	  
  	}else if (type == "Nonmetric"){
  	  cat("NON-METRIC MULTIDIMENSIONAL SCALING \n\n")    
      capture.output(fit <- metaMDS(tempData[, vars], distance = tolower(distance), k=as.numeric(dimnum), model="global"))
		
  		cat("\nPOINTS \n\n")
		  print(fit$points[1:dim(fit$points)[1], 1:dimnum])
		
      #print gof
  	  cat("\nGOODNESS OF FIT \n ")
  	  gofOut <- data.frame(goodness(fit))
      colnames(gofOut) <- ""
      print(gofOut[1:length(gofOut)])

      #print stress statistic
      stressStat <- as.matrix(round(fit$stress, digits = 4))
  	  rownames(stressStat) <- ""
  	  cat("\nStress Statistic: ", stressStat[1,1], sep ="")
  	  cat("\n")
  	  
      #create stressplot
      png(filename = paste(outputPath,"Stressplot.png",sep=""))
      stressplot(fit)
      dev.off()
	}
  
  #create plot
  grpLevels=levels(factor(data[, idVar]))
  
  mdsGraph(outputPath, grpLevels, dimnum, fit, type, useIdVar, pChars, pSizes, pCol,
           showLeg, legTitle, legPos, legNcol)
  
	return(list(Results = fit, Method= type))
}#-- end stmt (mds Function)--#


