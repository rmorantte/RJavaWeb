fnam = paste(QTL.path,"/QTL_", tolower(trait), '_',  tolower(method), '.Rdata', sep = '')
pngFile = paste(QTL.path,"/QTLmap_", trait, '_', method,".png",sep="")
}
save(QTL.result, file = fnam)
#pdf(file = pdfFile,onefile=TRUE);
png(file = pngFile);
print(xyplot(-log10(outem[,4])~ outem[,3] | factor(outem[,2]), type="l", layout=c(nchr(file),1), col="red", xlab="Chromosome position", ylab="-log10(P)", main=paste("QTL mapping", method, sep=""), scales = list(x = "free"), ylim=c(0,max), lwd=3,panel = function(x,y,...) {panel.abline(h =-log10(threshold.f),lty=2);llines(x,y,col="red",lwd=2)}));
dev.off()
dev.off()
data <- read.csv(paste(outputPath,"/GeneticDistMatrix.csv",sep=""), header = TRUE, na.strings = c("NA",".",""), blank.lines.skip = TRUE, sep = ",")
mdsGraph <- function(data, idVar, outputPath, pCharName = NULL, pColName, grpLevels = NULL, idData, dimnum, fit, type, useIdVar = FALSE, pChars, pSizes, pCol,
showLeg, legTitle, legPos, legNcol)
UseMethod("mdsGraph")
mdsGraph.default <- function(data, idVar, outputPath, pCharName=NULL, pColName, grpLevels = NULL, idData, dimnum, fit, type, useIdVar = FALSE, pChars, pSizes, pCol,
showLeg, legTitle, legPos, legNcol) {
x <- fit$points
if (useIdVar) {
plotType = "n"
pChars = grpLevels
pCharData = rownames(x)
} else {
plotType = "p"
pCharData = data[,pCharName]
}
if (dimnum == 2){
png(filename = paste(outputPath,"MDS_Coords1and2.png",sep=""))
plot(x[,1], x[,2], xlab = "Coordinate 1", ylab = "Coordinate 2", main = paste(type,"MDS"),
type = plotType, pch = pCharData, cex = pSizes, col = as.vector(data[,pColName]))
if (useIdVar) text(x[,1], x[,2], labels = idData, cex = pSizes, col = as.vector(data[,pColName]))
if (showLeg)
legend(legPos, title = legTitle, legend = grpLevels, pch = pChars, cex = pSizes, col = pCol, ncol = legNcol)
dev.off()
} else if (dimnum > 2){
for (i in 1:(dimnum-1)) {
jlim = i+1
for (j in jlim:dimnum) {
png(filename = paste(outputPath,"MDS_Coords", i, "and", j, ".png",sep=""))
plot(x[,i], x[,j], xlab = paste("Coordinate", i), ylab = paste("Coordinate", j), main = paste(type,"MDS"),
type = plotType, pch = pCharData, cex = pSizes, col = as.vector(data[,pColName]))
if (useIdVar) text(x[,i], x[,j], labels = idData, cex = pSizes, col = as.vector(data[,pColName]))
if (showLeg)
legend(legPos, title = legTitle, legend = grpLevels, pch = pChars, cex = pSizes, col = pCol, ncol = legNcol)
dev.off()
}
}
}
}#-- end --#
#---------------------------------------------------------#
#MDS - Function for performing Multidimensional Scaling   #
#
# data - name of R dataframe
# outputPath - folder where graph(s) will be saved
# inputType - whether input is from raw data or distance Matrix
# vars - vector of names of the numeric variables
# idVar - name of the ID variable
# distance - distance measure to use
# type - type of MDS to perform
# dimnum - number of dimensions to be used
# useIdVar - logical; whether an ID variable will be used to label points in the plot or not
# pChars - vector representing characters for the points in the plot
# pSizes - vector representing sizes of points in the plot
# pCol - vector representing colors of points in the plot
# showLeg - logical; whether a legend is displayed or not
# legTitle - title of the legend, if any
# legPos - position of the legend in the plot
# legNcol - number of columns for the legend
#---------------------------------------------------------#
MDS <-function(data, outputPath, inputType = c("raw", "distMat"), vars = NULL, idVar, type = c("Classical", "Nonmetric"),
distClass = c("Euclidean", "Maximum", "Manhattan", "Canberra", "Minkowski"),
distNonmet = c("Manhattan", "Euclidean", "Canberra", "Bray", "Kulczynski", "Jaccard", "Gower", "AltGower", "Morisita", "Horn", "Mountford", "Raup", "Binomial", "Chao", "Cao"),
dimnum = 2, useIdVar = FALSE, pChars, pSizes, pCol,
showLeg = FALSE, legTitle, legPos = "bottomright", legNcol = 1, descriptive = FALSE, correlate = FALSE)
UseMethod("MDS")
MDS.default <- function(data, outputPath, inputType = c("raw", "distMat"), vars = NULL, idVar, type = c("Classical", "Nonmetric"),
distClass = c("Euclidean", "Maximum", "Manhattan", "Canberra", "Minkowski"),
distNonmet = c("Manhattan", "Euclidean", "Canberra", "Bray", "Kulczynski", "Jaccard", "Gower", "AltGower", "Morisita", "Horn", "Mountford", "Raup", "Binomial", "Chao", "Cao"),
dimnum = 2, useIdVar = FALSE, pChars, pSizes, pCol,
showLeg = FALSE, legTitle, legPos = "bottomright", legNcol = 1, descriptive = FALSE, correlate = FALSE)
{
if (is.character(data)) {
nameData <- data
if (!exists(nameData)) { stop(paste("The object '", nameData,"' does not exist.", sep = "")) }
tempData <- eval(parse(text = data))
} else {
if (is.data.frame(data)) {
nameData <- paste(deparse(substitute(data)))
tempData <- data
} else { stop ("The argument should either be a data frame or a character string indicating the name of the data frame.") }
}
if (inputType == "raw") {
data[, idVar] <- factor(data[, idVar])
# -- PRINTING CLASS LEVEL INFORMATION -- #
#ClassInformation(data[, c(vars, idVar)], respvar = vars)
#cat("\n\n")
numObsNM = nrow((na.omit(data[,vars])))
numObs = nrow((data[,vars]))
if (numObs == numObsNM) { cat("Number of Observations:", numObs,"\n")
} else {
cat("Number of Observations:", numObs,"\n")
cat("Number of Observations Used:", numObsNM,"\n\n")
}
tempData <- na.omit(tempData[,c(vars, idVar)])
} else {
tempData <- na.omit(tempData)
d2 <- as.matrix(tempData[,-1])
#     rownames(d2) <- tempData[,1]
rownames(d2) <- NULL
colnames(d2) <- NULL
if (!isSymmetric(d2)) { stop ("Input matrix should be symmetric.")}
}
if (!is.data.frame(tempData)) { stop("The object should be of type data frame.") }
# 	if (!is.character(vars)) 	{ stop(paste("The object 'vars' should be a character vector.", sep = "")) }
# 	if (any(is.na(match(vars, names(tempData))))) { stop("At least one item in the character vector 'vars' does not match any variable name in the dataset.") }
type <- match.arg(type)
options(width = 5000, digits = 6)
#   distClass <- match.arg(distClass)
#   distNonmet <- match.arg(distNonmet)
if (descriptive) {
DescriptiveStatistics(data = tempData, var = vars, statistics = c("nnmiss", "mean", "sd", "se.mean"))
cat("\n\n")
}
if (correlate) {
BivariateCorrelationTest(data = tempData, var = vars, method = "pearson", alternative = "two.sided", statistics = FALSE)
cat("\n\n")
}
if (type == "Classical") {
cat("CLASSICAL MULTIDIMENSIONAL SCALING \n\n")
if (inputType == "raw") {
distClass <- match.arg(distClass)
d <- dist(tempData[,vars], method = tolower(distClass))
} else d <- tempData[,-1]
capture.output(fit <- cmdscale(d, eig=TRUE, k=as.numeric(dimnum))) # k is the number of dimensions
points <- data.frame(fit$points)
colnames(points) <- make.unique(rep("MDS",dimnum+1),sep ="")[2:(dimnum+1)]
cat("\nPOINTS\n\n")
print(points)
cat("\n")
eigenOut <- data.frame(fit$eig)
# 	  cat("\nEIGENVALUES\n")
# 	  colnames(eigenOut) <- ""
#     print(eigenOut)
if (nrow(eigenOut)>10) { xLength = 10
} else xLength = nrow(eigenOut)
png(filename = paste(outputPath,"MDS_Screeplot.png",sep=""))
plot(as.numeric(rownames(eigenOut))[1:xLength], eigenOut[1:xLength,1], xaxt = "n", xlab = "Eigenvalue number", ylab = "Eigenvalue", main = paste(type,"Scree Plot"),
type = "b", pch = 16)
axis(1, at = as.numeric(rownames(eigenOut))[1:xLength])
dev.off()
cat("\nP_", dimnum, " criterion: ", round(fit$GOF[2], digits = 4), sep = "") #2nd GOF statistic
}else if (type == "Nonmetric"){
cat("NON-METRIC MULTIDIMENSIONAL SCALING \n\n")
#   	  distNonmet <- match.arg(distNonmet)
if (inputType == "raw") {
distNonmet <- match.arg(distNonmet)
if (tolower(distNonmet) == "bray") {
d <- vegdist(tempData[,vars], method = "bray")
} else d <- dist(tempData[,vars], method = tolower(distNonmet))
capture.output(fit <- monoMDS(d, k=as.numeric(dimnum)))
#       capture.output(fit <- metaMDS(tempData[, vars], distance = tolower(distNonmet), k=as.numeric(dimnum), model="global"))
} else {
d <- as.dist(tempData[,-1])
capture.output(fit <- monoMDS(d=d, k=as.numeric(dimnum)))
##        capture.output(fit <- metaMDS(tempData[,-1], distance = NULL, k=as.numeric(dimnum), model="global", autotransform = FALSE, wascores = FALSE, noshare = FALSE))
#       capture.output(fit <- metaMDS(tempData2, distance = distNonmetric, k=as.numeric(dimnum), model="global"))
}
cat("\nPOINTS \n\n")
print(fit$points[1:dim(fit$points)[1], 1:dimnum])
#       #print gof
#   	  cat("\nGOODNESS OF FIT \n ")
#   	  gofOut <- data.frame(goodness(fit))
#       colnames(gofOut) <- ""
#       print(gofOut[1:length(gofOut)])
#print stress statistic
stressStat <- as.matrix(round(fit$stress, digits = 4))
rownames(stressStat) <- ""
cat("\nStress Statistic: ", stressStat[1,1], sep ="")
cat("\n")
#       #create Shepard diagram
#       png(filename = paste(outputPath,"ShepardDiagram.png",sep=""))
#       shepOut <- Shepard(d=d,x=fit$points)
#   	  plot(shepOut, pch = ".")
#   	  lines(shepOut$x, shepOut$yf, type = "S")
#       dev.off()
#create stressplot
png(filename = paste(outputPath,"Stressplot.png",sep=""))
stressplot(fit)
dev.off()
#       #create scree plot
#       fit2<- NULL
#       stressValues <- NULL
#   	  if (nrow(tempData)>10) { nStress = 10
#   	  } else nStress = nrow(tempData)
# #       nStress = nrow(tempData)
#       for (i in 1:(nStress)) {
#         fit2 <- monoMDS(d=d, k=i)
#         stressValues[i] <- fit2$stress/100
#       }
#   	  png(filename = paste(outputPath,"MDS_Screeplot.png",sep=""))
#   	  plot(c(1:nStress), stressValues, xaxt = "n", xlab = "Dimension number", ylab = "Stress statistic", main = paste(type,"Scree Plot"),
#   	       type = "b", pch = 16)
#       axis(1, at = c(1:nStress))
#   	  dev.off()
}
#create plot
if (inputType == "raw")  {
grpLevels = levels(factor(data[, idVar]))
idData = data[,idVar]
} else {
grpLevels = levels(factor(data[,1]))
idData = data[,1]
}
#   if(!useIdVar) {
grpCode<- data.frame(grpLevels, pChars, pCol)
pCharNames <- make.unique(c(names(data),"pCharCode"), sep = "")
pCharName <- pCharNames[length(pCharNames)]
pColName <- make.unique(c(pCharNames,"pColCode"), sep = "")
pColName <- pColName[length(pColName)]
tempData2 <- cbind(data,grpCode$pChars[match(idData, grpCode[,"grpLevels"])], grpCode$pCol[match(idData, grpCode[,"grpLevels"])])
colnames(tempData2)[ncol(tempData2)-1]<- pCharName
colnames(tempData2)[ncol(tempData2)]<- pColName
#   } else {
#     pCharName = NULL
#     pColName = NULL
#     tempData2 = data
#   }
mdsGraph(tempData2, idVar, outputPath, pCharName, pColName, grpLevels, idData, dimnum, fit, type, useIdVar, pChars, pSizes, pCol,
showLeg, legTitle, legPos, legNcol)
return(list(Results = fit, Method= type))
}#-- end stmt (mds Function)--#
result <- try(MDS(data, paste(outputPath,"/",sep=""), "distMat", c(), "", "Classical", "Euclidean", "Euclidean", 2, TRUE, c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), c(1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0), c(rgb(0, 0, 0, max=255)), FALSE, "Legend:", "bottomright", 1, FALSE, FALSE), silent = TRUE)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8')
QTLselected <- QTL.analysis(crossobj = crossData2, QTL.path = outputPath, geno = genoName, env.label = NULL, env = NULL, trait = yVars[i],
step = stepCIM, method = "SIM", threshold = thresholdWUR, distance = distWUR, cofactors = NULL, window.size = winCIM)
###
# library(STAR)
source('E:/StarPbtools/QTL/irri_new/trimStrings.R')
source('E:/StarPbtools/QTL/irri_new/QTL_dataprep.R')
source('E:/StarPbtools/QTL/irri_new/createQTLdata.R')
source('E:/StarPbtools/QTL/irri_new/checkQTLdata.R')
source('E:/StarPbtools/QTL/irri_new/DA_IWN_PDF.R')
source('E:/StarPbtools/QTL/irri_new/manageQTLmissing.R')
source('E:/StarPbtools/QTL/irri_new/testQTLsegregation.R')
source('E:/StarPbtools/QTL/irri_new/compareGenotypes.R')
source('E:/StarPbtools/QTL/irri_new/checkMarkerOrder.R')
source('E:/StarPbtools/QTL/irri_new/checkGenoError.R')
source('E:/StarPbtools/QTL/irri_new/checkQTLdata.R')
source('E:/StarPbtools/QTL/irri_new/doQTLanalysis.R')
library(qtl)
###input files
outputPath = "E:/App Files/workspace_Juno/RJavaManager/sample_datasets"
# input data files - as in current PBTools
dataFormat = "default"
format1 ="csv"
file1 <- "E:/StarPbtools/QTL/irri_new/data/listeria1_pheno.csv"
#genotypic and map files
format2 = "csv"
file2 <- "E:/StarPbtools/QTL/irri_new/data/listeria1_geno.csv"
format3 = "csv"
file3 <- "E:/StarPbtools/QTL/irri_new/data/listeria1_map.csv"
P_geno = "Geno"
crossType = "f2"
bcNum = 0
fNum = 0
QTLdata <- createQTLdata(outputPath, dataFormat, format1, crossType, file1, format2, file2, format3, file3,
P_geno, bcNum, fNum)
library(qtl)
library(qtlbook)
library(qtlbim)
library(qtl)
library(lattice)
crossData = QTLdata$crossObj
#Input5
traitType = "Continuous"  #c("Continuous", "Binary", "Ordinal"), yVars, method = c("IM", "CIM", "MQM", "BM")
yVars = c("T264") # c("pheno") #
method = "CIM"
genoName = "Geno"
stepCalc = 0
errCalc = 0.01
mapCalc = "haldane" #c("haldane","kosambi","c-f","morgan")
nPermutations = 100 #100
phenoModel = "normal" #c("normal","binary","2part","np")
methodIM = "em" #c("em","imp","hk","ehk","mr","mr-imp","mr-argmax")
lodCutoff = 3
numCovar = 3
winCIM = 10
thresholdWUR = 0.10 # "Li&Ji"
distWUR = 10
stepCIM = 10
cat("QTL ANALYSIS\n\n")
crossData2 <- crossData
cat("Method: Composite Interval Mapping\n\n")
i=1
QTLselected <- QTL.analysis(crossobj = crossData2, QTL.path = outputPath, geno = genoName, env.label = NULL, env = NULL, trait = yVars[i],
step = stepCIM, method = "SIM", threshold = thresholdWUR, distance = distWUR, cofactors = NULL, window.size = winCIM)
QTLselected$selected$marker
if (!is.null(QTLselected$selected$marker)) {
QTLOutCIMWUR <- QTL.analysis(crossobj = crossData2, QTL.path = outputPath, geno = genoName, env.label = NULL, env = NULL, trait = yVars[i],
step = stepCIM, method = "CIM", threshold = thresholdWUR, distance = distWUR, cofactors = QTLselected$selected$marker, window.size = winCIM)
}
QTLOutCIMWUR
QTLOutCIMWUR$selected
printDataFrame(QTLOutCIMWUR$selected)
plot(QTLOutCIMWUR)
plot(QTLOutCIMWUR$all)
QTLOutCIMWUR$all$marker
plot(QTLOutCIMWUR$all$marker,QTLOutCIMWUR$all$LOD)
cimOut2
plot(QTLOutCIMWUR$all$LOD ~ QTLOutCIMWUR$all$Pos|QTLOutCIMWUR$all$Chr)
plot(QTLOutCIMWUR$all$LOD ~ QTLOutCIMWUR$all$Chr|QTLOutCIMWUR$all$Pos)
plot(QTLOutCIMWUR$all$LOD ~ QTLOutCIMWUR$all$Pos|QTLOutCIMWUR$all$Chr)
plot(QTLOutCIMWUR$all$LOD ~ QTLOutCIMWUR$all$Chr|QTLOutCIMWUR$all$Pos)
xyplot(QTLOutCIMWUR$all$LOD ~ QTLOutCIMWUR$all$Pos|QTLOutCIMWUR$all$Chr)
xyplot(QTLOutCIMWUR$all$LOD ~ QTLOutCIMWUR$all$Chr|QTLOutCIMWUR$all$Pos)
plot(LOD ~ Pos|Chr, data = QTLOutCIMWUR)
plot(LOD ~ Pos|Chr, data = QTLOutCIMWUR$all)
QTLOutCIMWUR$all
plot(QTLOutCIMWUR$all$LOD ~ QTLOutCIMWUR$all$Pos|factor(QTLOutCIMWUR$all$Chr))
-log10(0.10)
-log10(0.05)
-log10(0.01)
-log10(0.001)
print(xyplot(LOD ~ Pos | factor(Chr), data = QTLOutCIMWUR$all , type="l", col="red", xlab="Chromosome position", ylab="-log10(P)", main="QTL mapping", scales = list(x = "free"), ylim=c(0,max), lwd=3,panel = function(x,y,...) {panel.abline(h =-log10(0.001),lty=2);llines(x,y,col="red",lwd=2)}));
xyplot(LOD ~ Pos | factor(Chr), data = QTLOutCIMWUR$all , type="l", col="red", xlab="Chromosome position", ylab="-log10(P)", main="QTL mapping", scales = list(x = "free"), ylim=c(0,max), lwd=3,panel = function(x,y,...) {panel.abline(h =-log10(0.001),lty=2);llines(x,y,col="red",lwd=2)}));
xyplot(LOD ~ Pos | factor(Chr), data = QTLOutCIMWUR$all , type="l", col="red", xlab="Chromosome position", ylab="-log10(P)", main="QTL mapping", scales = list(x = "free"), ylim=c(0,max), lwd=3,panel = function(x,y,...) {panel.abline(h =-log10(0.001),lty=2);llines(x,y,col="red",lwd=2)})
plot(LOD ~ Pos|Chr, data = QTLOutCIMWUR$all, type = "l")
print(xyplot(-log10(outem[,4])~ outem[,3] | factor(outem[,2]), type="l", layout=c(nchr(file),1), col="red", xlab="Chromosome position", ylab="-log10(P)", main=paste("QTL mapping", method, sep=""), scales = list(x = "free"), ylim=c(0,max), lwd=3,panel = function(x,y,...) {panel.abline(h =-log10(threshold.f),lty=2);llines(x,y,col="red",lwd=2)}));
xyplot(LOD ~ Pos | factor(Chr), data = QTLOutCIMWUR$all , type="l", col="red", xlab="Chromosome position", ylab="-log10(P)", main="QTL mapping", scales = list(x = "free"), ylim=c(0,max), lwd=3,panel = function(x,y,...) {panel.abline(h =-log10(0.001),lty=2);llines(x,y,col="red",lwd=2)})
threshold.f
file
nchr(file)
xyplot(LOD ~ Pos | factor(Chr), data = QTLOutCIMWUR$all , type="l", col="red", xlab="Chromosome position", ylab="-log10(P)", main="QTL mapping", scales = list(x = "free"), ylim=c(0,max), lwd=3,panel = function(x,y,...) {panel.abline(h =-log10(0.01),lty=2);llines(x,y,col="red",lwd=2)})
xyplot(LOD ~ Pos | factor(Chr), data = QTLOutCIMWUR$all , type="l", layout=c(nchr(file),1), col="red", xlab="Chromosome position", ylab="-log10(P)", main="QTL mapping", scales = list(x = "free"), ylim=c(0,max), lwd=3,panel = function(x,y,...) {panel.abline(h =-log10(0.01),lty=2);llines(x,y,col="red",lwd=2)})
xyplot(LOD ~ Pos | factor(Chr), data = QTLOutCIMWUR$all , type="l", layout=c(nchr(file),1), col="red", xlab="Chromosome position", ylab="-log10(P)", main="QTL mapping", scales = list(x = "free"), ylim=c(0,max), lwd=3,panel = function(x,y,...) {panel.abline(h =-log10(0.1),lty=2);llines(x,y,col="red",lwd=2)})
library(qtl)
###input files
outputPath = "E:/App Files/workspace_Juno/RJavaManager/sample_datasets"
# input data files - as in current PBTools
dataFormat = "default"
format1 ="csv"
file1 <- "E:/StarPbtools/QTL/irri_new/data/listeria1_pheno.csv"
#genotypic and map files
format2 = "csv"
file2 <- "E:/StarPbtools/QTL/irri_new/data/listeria1_geno.csv"
format3 = "csv"
file3 <- "E:/StarPbtools/QTL/irri_new/data/listeria1_map.csv"
P_geno = "Geno"
crossType = "f2"
bcNum = 0
fNum = 0
QTLdata <- createQTLdata(outputPath, dataFormat, format1, crossType, file1, format2, file2, format3, file3,
P_geno, bcNum, fNum)
library(qtl)
library(qtlbook)
library(qtlbim)
library(qtl)
library(lattice)
crossData = QTLdata$crossObj
#Input1
traitType = "Continuous"  #c("Continuous", "Binary", "Ordinal"), yVars, method = c("IM", "CIM", "MQM", "BM")
yVars = c("T264")
method = "IM"
stepCalc = 0
errCalc = 0.01
mapCalc = "haldane" #c("haldane","kosambi","c-f","morgan")
nPermutations = 100 #100
phenoModel = "normal" #c("normal","binary","2part","np")
methodIM = "em" #c("em","imp","hk","ehk","mr","mr-imp","mr-argmax")
lodCutoff = 3
cat("QTL ANALYSIS\n\n")
crossData2 <- crossData
mMethod
mMethod = "IM"
mMethod
crossData2 <- calc.genoprob(crossData2, step = stepCalc, error.prob = errCalc, map.function = mapCalc)
cat("Method: Interval Mapping\n\n")
i=1
#find column location for phenotypes
colno <- match(yVars[i], names(crossData2$pheno))
cat("Trait: ", yVars[i], "\n\n")
(is.na(lodCutoff))
imOut2 <- scanone(crossData2, pheno.col = colno, model = phenoModel, method = methodIM)
imOutDF <- cbind(Marker = rownames(imOut2),as.data.frame(imOut2))
imOutDFSel <- imOutDF[which(imOutDF$lod > lodCutoff),]
cat("Markers with lod scores above the cut-off:\n\n")
printDataFrame(imOutDFSel)
plot(imOut2)
abline(h = lodCutoff, lty=2, col = "blue")
plot(imOut2, col = "red")
abline(h = lodCutoff, lty=2, col = "blue")
plot(imOut2, col = "red")
abline(h = lodCutoff, lty=2, col = "black")
xyplot(imOut2, col = "red")
imOut2
names(imOut2)
QTLOutCIMWUR$all
plot(LOD,Pos,data=QTLOutCIMWUR$all)
QTLOutCIMWUR$all
plot(LOD ~ Pos|Chr, data = QTLOutCIMWUR$all, type = "l")
plot(LOD~Pos,data=QTLOutCIMWUR$all)
plot(LOD~Chr,data=QTLOutCIMWUR$all)
plot(LOD~Chr,data=QTLOutCIMWUR$all, type = "l")
plot(LOD~Pos|Chr,data=QTLOutCIMWUR$all, type = "l", col = "red")
plot(LOD~Chr|Pos,data=QTLOutCIMWUR$all, type = "l", col = "red")
plot(LOD~Pos|Chr,data=QTLOutCIMWUR$all, type = "l", col = "red")
plot(LOD~Pos,data=QTLOutCIMWUR$all, type = "l", col = "red")
plot(LOD~Chr,data=QTLOutCIMWUR$all, type = "l", col = "red")
plot(LOD~Pos|factor(Chr),data=QTLOutCIMWUR$all, type = "l", col = "red")
plot(LOD~Pos,data=QTLOutCIMWUR$all, type = "l", col = "red")
plot(LOD~Pos|factor(Chr),data=QTLOutCIMWUR$all, type = "l", col = "red")
a <- list()
a[1] = 0
for (i in 1:10)
a[i] <- i + a[i-1]
a <- list()
for (i in 1:10)
a[i] <- i + 1
a
head(a)
a <- NULL
# a[1] = 0
for (i in 1:10)
a[i] <- i + 1
a
typeof(a)
summary(a)
b<-NULL
summary(b)
b<-c(1,2,3)
b
sum(b)
summary(b)
b<-NA
b
summary(b)
b<-c(NA,NA,NA)
b
summary(b)
b<-c(NULL,NULL,NULL)
b
summary(b)
source('E:/StarPbtools/QTL/irri_new/doQTLanalysis.R')
crossData
crossData$geno
crossData$pheno
source('E:/StarPbtools/QTL/irri_new/trimStrings.R')
source('E:/StarPbtools/QTL/irri_new/QTL_dataprep.R')
source('E:/StarPbtools/QTL/irri_new/createQTLdata.R')
source('E:/StarPbtools/QTL/irri_new/checkQTLdata.R')
source('E:/StarPbtools/QTL/irri_new/DA_IWN_PDF.R')
source('E:/StarPbtools/QTL/irri_new/manageQTLmissing.R')
source('E:/StarPbtools/QTL/irri_new/testQTLsegregation.R')
source('E:/StarPbtools/QTL/irri_new/compareGenotypes.R')
source('E:/StarPbtools/QTL/irri_new/checkMarkerOrder.R')
source('E:/StarPbtools/QTL/irri_new/checkGenoError.R')
source('E:/StarPbtools/QTL/irri_new/checkQTLdata.R')
source('E:/StarPbtools/QTL/irri_new/doQTLanalysis.R')
source('E:/StarPbtools/QTL/irri_new/qtl_cimwur.R')
library(qtl)
###input files
outputPath = "E:/App Files/workspace_Juno/RJavaManager/sample_datasets"
dataFormat = "default"
format1 ="csv"
file1 <- "E:/StarPbtools/QTL/irri_new/data/listeria1_pheno2.csv"
format2 = "csv"
file2 <- "E:/StarPbtools/QTL/irri_new/data/listeria1_geno.csv"
format3 = "csv"
file3 <- "E:/StarPbtools/QTL/irri_new/data/listeria1_map.csv"
P_geno = "Geno"
crossType = "f2"
bcNum = 0
fNum = 0
QTLdata <- createQTLdata(outputPath, dataFormat, format1, crossType, file1, format2, file2, format3, file3,
P_geno, bcNum, fNum)
QTLdata <- createQTLdata(outputPath, dataFormat, format1, crossType, file1, format2, file2, format3, file3,
P_geno, bcNum, fNum)
QTLdata <- createQTLdata(outputPath, dataFormat, format1, crossType, file1, format2, file2, format3, file3,
P_geno, bcNum, fNum)
QTLdata$pheno
crossData = QTLdata$crossObj
crossData$pheno
source('E:/StarPbtools/QTL/irri_new/trimStrings.R')
source('E:/StarPbtools/QTL/irri_new/QTL_dataprep.R')
source('E:/StarPbtools/QTL/irri_new/createQTLdata.R')
source('E:/StarPbtools/QTL/irri_new/checkQTLdata.R')
source('E:/StarPbtools/QTL/irri_new/DA_IWN_PDF.R')
source('E:/StarPbtools/QTL/irri_new/manageQTLmissing.R')
source('E:/StarPbtools/QTL/irri_new/testQTLsegregation.R')
source('E:/StarPbtools/QTL/irri_new/compareGenotypes.R')
source('E:/StarPbtools/QTL/irri_new/checkMarkerOrder.R')
source('E:/StarPbtools/QTL/irri_new/checkGenoError.R')
source('E:/StarPbtools/QTL/irri_new/checkQTLdata.R')
source('E:/StarPbtools/QTL/irri_new/doQTLanalysis.R')
source('E:/StarPbtools/QTL/irri_new/qtl_cimwur.R')
library(qtl)
QTLdata <- tryCatch(createQTLdata("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/", "default", "csv", "f2", "E:/App Files/workspace_Juno/RJavaManager/sample_datasets/listeria1_pheno.csv", "csv", "E:/App Files/workspace_Juno/RJavaManager/sample_datasets/listeria1_geno.csv", "csv", "E:/App Files/workspace_Juno/RJavaManager/sample_datasets/listeria1_map.csv", "Geno", 0, 0))
crossData = QTLdata$crossObj
crossData
sink(paste("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/","markerQC.txt", sep = ""))
chkQTLdata <- checkQTLdata("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/", crossData, "f2", 0, 0, TRUE, TRUE, 0.15, TRUE, 0.01, TRUE, 0.7, TRUE, 3.0, TRUE, 5.0, 0.01)
sink()
sink(paste("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/","QTLout_IM.txt", sep = ""))
runQTL <- doQTLanalysis(E:/App Files/workspace_Juno/RJavaManager/sample_datasets/", crossData, "Continuous",[Ljava.lang.String;@89ae9e, "IM", 0.0, 0.01 , "haldane", 3.0, "normal", "em", 100, 1, 10.0, "NULL", 0.0, 10.0, 5.0, false, 1, true)
runQTL <- doQTLanalysis("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/", crossData, "Continuous",[Ljava.lang.String;@89ae9e, "IM", 0.0, 0.01 , "haldane", 3.0, "normal", "em", 100, 1, 10.0, "NULL", 0.0, 10.0, 5.0, false, 1, true)
runQTL <- doQTLanalysis("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/", crossData, "Continuous", c("T264"), "IM", 0.0, 0.01 , "haldane", 3.0, "normal", "em", 100, 1, 10.0, "NULL", 0.0, 10.0, 5.0, FALSE, 1, TRUE)
sink(paste("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/","QTLout_IM.txt", sep = ""))
runQTL <- doQTLanalysis("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/", crossData, "Continuous", c("T264"), "IM", 0.0, 0.01 , "haldane", 3.0, "normal", "em", 100, 1, 10.0, "NULL", 0.0, 10.0, 5.0, FALSE, 1, TRUE)
sink()
sink()
sink()
sink(paste("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/","QTLout_IM.txt", sep = ""))
runQTL <- doQTLanalysis("E:/App Files/workspace_Juno/RJavaManager/sample_datasets/", crossData, "Continuous", c("T264"), "IM", 0.0, 0.01 , "haldane", 3.0, "normal", "em", 100, 1, 10.0, "NULL", 0.0, 10.0, 5.0, FALSE, 1, TRUE)
sink()
